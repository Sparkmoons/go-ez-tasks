## Теория

Это моя "бывшая" заметка с теорией, в которую я все валил в кучу, после просмотра материала. 

## Полезное

Разработка языка началась в 2007 году в компании Google, разработкой занимались Роб Пайк, Роберт Гринзмер и Кен Томпсон.
Официально язык был представлен в ноябре 2009. 

Компилируемый многопоточный язык со статической типизацией данных, асинхронный. Императивный (как сделать) ((есть еще декларативный - что сделать))

Любая программа состоит трех базовых конструкций из: последовательности, ветвления и цикла 
(Архитектуры, Кода и Интерпритатора)
(Данные, Алгоритм обработки этих данных и Пользовательского интерфейса)

Аллокация памяти - выделение памяти. 
Пакет - коллекция исходоых файлов .go в одной директории и с одинаковой директивой package. 
GOROOT - каталог для стандартной библиотеки, вклюячая исполняемые файлы и исходныц код. 
GOPATH - каталог для внешних пакетов. 

Программа GO содержит: 
- рантайм - код, который выполняется в нашей программе, но который мы сами не вызывали (планировщик, сборщик мусора ((TBD)), аллокатор памяти ((TBD)))
- Обширная стандартная библиотека
- Отладочная информация

Планировщик - маленькая ОС внутри каждой программы, которая управляет работой горутин. 
Треды/потоки ОС позволяют множеству программ работать на одном процессоре одновременно. Но они сравнительно тяжелые, медленные, непредсказуемые. Горутины как треды, но лучше в контроле, экономии ресурсов, эффективном переключении между горутинами. 

## Тред — Процессор — Горутина
Количество процессоров Р (обычно) равно количеству ядер. Количество тредов М (обычно) равно Р. Количество горутин неограниченно. У каждого процессора Р есть своя очередь горутин, которую тот должен выполнять.
Например, если в многоядерном режиме на одном процессоре(P1) все горутины закончились, а на другом(P2) в локальной очереди они еще остались, то P1 захватит половину горутин у P2. Из глобальной очереди поступи задача на выполнение, когда в локальной очереди не останется горутин.

Многозадачность в го: неявная кооперативность (кооперативность - программы выполняются столько, сколько им нужно и программы сами уступают себе место)

Принципы планировщика GO: Очередь FIFO, Необходимый минимум тредов (тред не закрывается, а пытается облегчить другие задачи), Захват чужой работы (до этого написал), Неивазивность (не прирывает нативно работу горутин)

Ограничения планировщика GO: Очередь FIFO (нет важности и приоритетности), Отсутствие гарантий времени выполнения (не подойдёт для самолетов, звездолетов, больниц…), Горутины могут перемещаться между тредами, что снижает эффективность кэшей
(go перед горутиной это всего лишь удобный слой абстракции, никакой магии нет)

API - Application Program Interface

## Плюсы и минусы

Хорош для веб-серверной разработки
Плюс: очень быстро собирает приложения для любых платформ, быстрый перфоманс, простота кода 

Технологические преимущества: 
Параллелизм, Кросплатформенность, Скорость и Компиляция, Статическая типизация, Богатая стандартная библиотека, Возможность писать в функциональном стиле, Нет ООП, Простой и понятный синтаксис, Open Source, Разработали в Google

Недостатки: 
Быстрый, но С и С++ быстрее, Нет ООП, Проверка на ошибку if err

Можно сделать все, вопрос в том, на сколько хорошо это будет. 

Структура не может быть константой. 
Если в структуре есть другая структура - сравнить не получится. 

Структуру нельзя сравнить с nil. Указатель можем сравнить с nil. 

Почти все в го реализовано через структуры!

## Массив и слайс

Массив - упорядоченный набор элементов фиксированной длины.

Создание массива: 1) var mass [8]int    2) mass := [8]int{}
В обоих случаях были созданы массивы с длиной (len) равной 8. В квадратных скобках, перед названием типа, можно указать три точки (...), если мы не хотим считать длину массива.
Значение из массивов можно получать по значению. В массиве, как в дальнейшем и слайсе, содержатся элементы одного типа. Это могут быть: целочисленные значения, вещественные типы, символьные типы, строковые типы, логический тип.

Перебор массива:
```go
for i,v:=range mass{}    // - i выводит порядок в масиве, v выводит значение. Чтобы выводить только значение меняем i на _
```


Слайс - это надмножество у массива. Он более гибкий, может расширяться, его длину не нужно указывать в квадратных скобках.
Создание слайса: 1) var sl []int    2) sl := make([]int, 5, 5)
В примере 2 мы создали слайс с длиной 5 (len = 5) и емкостью 5 (cap = 5). При инициализации можно не указывать cap, а вместо len указать 0.
Также, слайс можно создать из имеющегося массива:
mass := [8]int{1, 2, 3, 4, 5, 6, 7, 8}
1) sl := mass[2:6] - слайс содержит первые 4 элемента массива mass (3, 4, 5, 6 - элементы, первый включается - последний не включается)
2) sl := mass[:3] - слайс содержит первые 3 элемента массива mass (1, 2, 3 - элементы)
3) sl := mass[3:] - слайс содержит все элементы массива mass после 3 (4, 5, 6, 7, 8 - элементы)

Как слайс выглядит внутри
```go
struct {
    array *[]T    //ссылка на исходный массив
    len int       //длина
    cap int       //вместимость
}
```
Для добавления числа в слай используется append. Происходит добаввление значения в конец слайса. В примере ниже мы добавляем в слайс res элемент 3. В скобках у append указывается: 1) куда добавить, 2) что добавить.
Слайсы можно копировать через copy. Нужно создать слайс, куда мы будем копировать и перенести в него данные. Сравнивать через == или != нельзя, можно сравнивать только с nil.
```go
//добавление
res := make([]int, 0)
res = append(res, 3)

//копирование
sl1 := []int{1, 2, 3}
sl2 := make([]int, len(sl1), cap(sl2))
copy(sl2, sl1)  
```

Различие массива и слайса:

1. Срез - всегда указатель на массив, массив - значение. 
2. Срез может менять свой размер и динамически аллоцировать в память.  Емкость массива объявляется в момент его создания, и после изменить ее нельзя. 

Изменение данных среза приводит к изменению соответствующего элемента нижележащего массива. 

Размер среза - это количество элементов, которые он содержит.
Вместимость среза - это количество элементов в его нижележащем массиве, начиная с первого элемента в срезе.
Размер и вместимость среза s могут быть получены с помощью len(s) и cap(s).

## Интерфейсы
Интерфейсы описывает действия объекта. Что может делать та или иная структура. 

``` go
type Walking interface {
    Walk()
}
```

Интерфейс внутри - структура, у него есть динамическое значение и динамический тип. Хранит информацию о методах, которые он требует реализовать. 
Самые популярные интерфейсы - интерфейсы из пакета IO - Writer, Reader, Closer. 
Интерфейс - единственный представитель абстрактного типа данных в языке. Он определяет поведение типов. 
Чем меньше методов в интерфейсе - тем лучше. Если метод один, его имя образовано от имени интерфейса (существительным, сам интерфейс - глагол). 
Интерфейсы помогают разделять уровни абстракций, повышают гибкость кодовой базы, nil не всегда просто nil, пустым интерфейсом нужно пользоваться аккуратно. 

Интерфейсы — это инструменты для определения наборов действий и поведения. Интерфейсы — это в первую очередь контракты. Они позволяют объектам опираться на абстракции, а не фактические реализации других объектов. При этом для компоновки различных поведений можно группировать несколько интерфейсов. В общем смысле — это набор методов, представляющих стандартное поведение для различных типов данных. 
(Как пример - геометрические фигуры и площади. Структура для каждой фигуры, для каждой структуры метод с расчетом площади, и этот метод в интерфейсе. После этого функция посчитает сумму. )
Пустой интерфейс - это интерфейс для реализации которого не нужно описывать ни одного метода. 
Через switch можно определить тип интерфейса. 

```go
t := i.(T)
```

Эта инструкция утверждает, что интерфейсное значение i содержит конкретное значение типа T, и присваивает нижележащее значение T переменной t.
Если i не содержит T, то это приведет к panic.
Чтобы проверить, содержит ли интерфейсное значение конкретный тип, оператор приведения типа может вернуть два значения: нижележащее значение и булевое значение, указывающее, была ли операция приведения типа успешной.

```go
t, ok := i.(T)
```
Если i содержит T, то t будет нижележащим значением и ok будет true.
Если нет, то ok будет false и t будет нулевым значением типа T, и не будет panic.

Если нижележащим значением интерфейсного значения является nil, то метод будет вызван с получателем nil.
Вызов метода у nil интерфейса является ошибкой времени выполнения, т.к. внутри пары значение/тип нет типа, чтобы указать, какой конкретный метод надо вызвать. 
Обратите внимание, что если интерфейсное значение имеет nil в качестве нижележащего значения, то само по себе оно не nil.
Не нужно указывать явно, что наш тип реализует интерфейс (утиная типизация).Если тип реализует все методы, описанные в интерфейсе, то он считается реализующим.

```go
type Painter interface {
    Paint() string
}

type Person struct {
    Name string
}

func (p Person) Paint() string {
    return "It was drawn by " + p.Name
}
```

Интерфейсы лучше описывать на принимающей стороне. 


## ООП

ООП в го:
Наследования, как такового, нет. Можно заменить композицией (один класс является частью другого). Два варианта встраивания: 1 - структура в структуру, 2 - через конкретное поле с названием (через указатель?). Можно вставить без названия поля и будет как копирование содержимого. 
Инкапсуляция (скрытие данных) (в других языках private/public/protect). В го с маленькой буквы - private, с большой буквы - Public. 
Полиморфизм (множественное поведение одного и того же объекта) реализован через интерфейсы. Берем интерфейс, заводим парочку структур, которые реализуют этот интерфейс (то есть методы), они указывают поведение. 

## Типы

Типы данных: int, uint, string, byte (uint8), rune (int 32), float, complex, bool. 
Стандартные значения: 0 - для числовых переменных, false - для булевых, «» - для строк. 
```
Целочисленные типы:
    int8 - 8 бит (1 байт), от -128 до 127;
    int16 - 16 бит (2 байта), от -32768 до 32767;
    int32 - 32 бита (4 байта), от -2147483648 до -2147483647;
    int64 - 64 бита (8 байт), от -9223372036854775808 до 9223372036854775807;
    uint8 - 8 бит (1 байт), от 0 до 255;
    uint16 - 16 бит (2 байта), от 0 до 65535;
    uint32 - 32 бита (4 байта), от 0 до 4294967295;
    uint64 - 64 бита (8 байт), от 0 до 18446744073709551615;

Вещественные типы:
    float32 - 32 бита (4 байта) (плавающая точка одинарной точности)
    float64 - 64 бита (8 байт) (плавающая точка двойной точности)

Символьные типы:
    byte - 8 бит (1 байт) (синоним uint8)
    rune - 32 бита (4 байта) (синоним int32, используется для преставления Unicode символов)

Строковые типы:
    string - строка символов Unicode

Логический тип:
    bool - значения true или false
```

Строки - это массив байт, неизменяемые последовательности. Длина выводится через len (возвращает количество байт). Через len() можно узнать длину строки. 

Руны - rune (int32) (32 бита / 4 байта) - (1.var euro rune =‘e’ 2.euro:=‘e’ 3.euro:=rune(‘e’)) чтобы вывести символ, нужно руну привести к строке. 

```go
package main
import "fmt"
```
Массив: 
```go
fmt.Scanln(&xdd)     //- чтение с клавиатуры
fmt.Scan(&xdd)       //- чтение с клавиатуры
fmt.Println(xdd)     //- вывод нескольких элементов с новой строки
fmt.Print(xdd)       //- вывод нескольких элементов через пробел
```
Структура: 
```go
type Contact struct {
    name string  
    phone int
} (данные в новой строке каждый)
```
Метод:
```go
func (c *Contact) Call() {
    fmt.Println("Calling", c.name, "at", c.phone)
}
```
Интерфейс:
``` go
type Walking interface {
    Walk()
}
Функции:
```go
func abc (x int){} //- функция без возврата с приемом числа на вход
func abc (x int) int{} //- функция c возвратом с приемом числа на вход и возвращением числа
```
Switch:
```go
x := 2
switch x{
    case x == 2:
        fmt.Println("Двоечка!")
    case x != 2:
        fmt.Println("Мимо")
}
```
Считать строку с пробелами:
```go
s, _ := bufio.NewReader(os.Stdin).ReadString('\n')
```

## Cчитываем из терминала
```go
scanner := bufio.NewScanner(os.Stdin)
scanner.Scan()
input := scanner.Text()
```

## strconv

Существует удобный пакет "strconv" (import "strconv"), который применяют для преобразования числа в строку и наоборот.
strconv.Atoi(n) - преобразует строчное значени n к типу int.
strconv.Itoa(n) - преобразует значение n типа int к строке.

## Указатели

Указатель представляет собой переменную, которая содержит адрес в памяти другой переменной.
```go
a := 100 
var b *int = &a
var c **int = &b
```

а - значение а типа int;
&a - адрес а;
b - адрес а, указатель на переменную a типа int. Если меняется a - то меняется b;
*b - значение а;
c - адрес b;
*c - адрес а;
**с - значение а;

## Defer

Оператор defer гарантирует, что функция будет вызвана только после того, как вернется окружающая функция. Аргументы отложенных функций вычисляются сразу же, но вызываются при возврате из окружающей функции (сначала сработает строка под defer, потом выведется значение defer) defer some_func(). 
(Аргументы отложенного вызова функции вычисляются тогда, когда вычисляется команда defer.)
Если несколько defer, они будут работать по принципу FILO (first input last output) / LIFO
При вызове syscal (os.Exit(1), log.fatal) defer не сработает, так как процесс моментально завершится. 

## iota

iota - идентификатор, который позволяет создавать последовательные не типизированные целочисленные константы. 
Встроенная константа, которая используется вместе с оператором объявления констант (const), для создания последовательности значений начиная с нуля. 
Важно, iota работает для каждого блока const отдельно. При создании последующего блока const счетчик iota снова начнется с нуля. 

```go
const (
    X = iota  // X = 0
    Y = iota  // Y = 1 (значение iota увеличивается автоматически на 1)
)

const (
    Z = iota  // Z = 0 (значение iota снова становится 0 для нового блока const)
    W = iota  // W = 1 (значение iota увеличивается автоматически на 1)
)
```


## Map

Map - это структура, реализующая операции хэширования. Хранит пары ключ-значение. С мапами можно делать несколько операций: 1) поиск по значению ключа, 2) добавление в мапу, 3) удаление из мапы.
map[int]string - ключ int, значение string

## Методы 

Метод - функция, которая работает с определенными типами. 

Методы - это просто функции со специальным аргументом-получателем
(Метод - это всего лишь функция, для которой указан получатель.)
```go
func (x Contact) welcome() { 
    fmt.Println(x.name) 
    fmt.Println(x.age) 
}
```
Получатель указывается между ключевым словом func и именем метода. В приведенном выше примере приемником является структура Contact.

Для создания горутины (многопоточности) нужно добавить go перед названием функции: go out()
Создание канала: ch := make(chan int)
Отправка данных в канал: ch <- 8
Чтение данных из канала: value := <- ch, если не нужно знать значение переменной можно просто использовать: <- ch

Только отправитель данных должен закрывать канал, но никогда - получатель. Попытка отправить данные в закрытый канал вызовет panic.
Каналы не как файлы; обычно вам не надо их закрывать. Закрывать необходимо, только когда получателю надо указать, что данных для получения больше нет, например, для завершения цикла range.

Atomic - потокобезопасное применение счетчика. 

## Mutex

Мьютекс (mutex - mutual extension) - примитивы синхронизации.
```go
var mu sync.Mutex

mu.Lock()// - блокируем доступ
/*Что-то делаем (например, пишем значение в мапу/увеличиваем счетчик)*/
mu.Unlock() //- разблокируем доступ
//Эти 3 строки - критическая секция. 

var wg sync.WaitGroup

wg.Add()
defer wg.Done()
wg.Wait()
```

## Garbage Collector (GC)

GC выполняется конкурентно (concurrent), одновременно с потоками мутатора (mutator), в точном соответствии с типом (этот принцип также известен как чувствительность к типу), допускается параллельное выполнение нескольких потоков GC. Это конкурентная пометка и очистка (mark-sweep), при которой используется барьер записи (write barrier). При этом в процессе ничего не генерируется и не сжимается. Освобождение памяти выполняется на основе размера, выделенного для каждой программы Р, чтобы в общем случае минимизировать фрагментацию и избежать блокировок.

Сборщик мусора реализован по алгоритму Mark и Sweep. Неиспользуемые объекты в Go находит и удаляет сборщик мусора. 
Mark - разметка. Sweep - очистка памяти. 

Heap - очередь с приоритетами. 
Автоматически сборщик мусора запускается, когда heap увеличился вдвое. Вручную сборщик мусора можно запустить с помощью runtime.GC(). Сборщик потребляет до 25% CPU для фазы Mark. 

## JSON

JSON (JavaScript Object Notation) -текстовый формат обмена структурированными данными, основанны на JavaScript (еще есть XML, YAML, Google’s Protocol Buffers)

Тег json (например):
Name string `json:”name”`

json.Marshal() - сериализация, принимает аргумент типа interface{} и возвращает байтовый срез с данными, кодированными в формате JSON. 

json.MarahalIndent - похож на Marshal, но применяет отступ для форматирования вывода. 

json.Unmarshal() - принимает в качестве аргумента байтовый срез и указатель на объект, в который требуется декодировать данные. 

## Каналы

Из закрытого канала мы можем читать ранее записанные значения. Получаем дефолтное значение при запросе данных, которых в канале нет. Попытка отправки значения в закрытый канал вызовет панику. Это происходит так как после закрытия он больше не предназначен для записи и он остается доступным только для чтения. 

Пример записи в закрытый канал:
```go
ch := make(chan int, 5)
close(ch)
ch <- 1 // Это вызовет панику
```

- Отправка на нулевой канал блокируется навсегда
- Прием от нулевого канала блокируется навсегда
- Отправка в закрытый канал приводит к панике
- Прием из закрытого канала немедленно возвращает нулевое значение

Не буферизированные каналы - это каналы, которые не имеют внутреннего буфера и требуют блокировки отправителя и получателя при передаче данных. Это означает, что отправитель будет заблокирован до тех пор, пока получатель не прочитает данные из канала, и наоборот - получатель будет заблокирован до тех пор, пока отправитель не передаст данные.

Буферизированные каналы - это каналы, которые имеют внутренний буфер и позволяют отправителю передавать данные, даже если получатель еще не готов к их приему. Буферизированные каналы в Go позволяют уменьшить количество блокировок и увеличить производительность программы.

Приемники всегда блокируются, пока нет данных для приема. Если канал не буферизован, отправитель блокируется, пока получатель не получил значение. Если у канала есть буфер, отправитель блокируется только до того как значение было скопировано в буфер; если буфер заполнен, это означает ожидание, пока какой-либо получатель не получит значение.

Для каналов есть оператор select, для ожидания нескольких операций ввода-вывода одновременно. 
```go
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "первый канал"
    }()

    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "второй канал"
    }()

    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("Получено сообщение из", msg1)
        case msg2 := <-ch2:
            fmt.Println("Получено сообщение из", msg2)
        }
    }
}
```

## Docker

Docker — это платформа, которая позволяет упаковать в контейнер приложение со всем окружением и зависимостями, а затем доставить и запустить его в целевой системе.
Приложение, упакованное в контейнер, изолируется от операционной системы и других приложений. Поэтому разработчики могут не задумываться, в каком окружении будет работать их приложение, а инженеры по эксплуатации — единообразно запускать приложения и меньше заботиться о системных зависимостях.

Виртуализация в Docker реализуется на уровне ОС. Виртуальная среда запускается прямо из ядра основной операционной системы и использует её ресурсы.

Примеры использований: Разработки приложений с зависимостями, Автоматизация тестирования, Публикация приложения 
Минусы: Высокое потребление ресурсов, Для больших приложений нужен оркестратор (Kubernetes , OpenShift), На windows и Mac урезанные версии (проблемы с установкой, предназначение для Linux)

Kubernetes — это мощный слой абстракции над железом, альтернатива гипервизорам у виртуалок. Он позволяет настраивать политики безопасности, реализует различные схемы обновления и позволяет гибко управлять ресурсами.

## Recover Panic

Panic — это встроенная функция, которая останавливает обычный поток управления и начинает паниковать. Когда функция F вызывает panic, выполнение F останавливается, все отложенные вызовы в F выполняются нормально, затем F возвращает управление вызывающей функции. Для вызывающей функции вызов F ведёт себя как вызов panic. Процесс продолжается вверх по стеку, пока все функции в текущей го-процедуре не завершат выполнение, после чего аварийно останавливается программа. Паника может быть вызвана прямым вызовом panic, а также вследствие ошибок времени выполнения, таких как доступ вне границ массива.

Recover — это встроенная функция, которая восстанавливает контроль над паникующей го-процедурой. Recover полезна только внутри отложенного вызова функции. Во время нормального выполнения, recover возвращает nil и не имеет других эффектов. Если же текущая го-процедура паникует, то вызов recover возвращает значение, которое было передано panic и восстанавливает нормальное выполнение.

Вызов recover останавливает раскручивание и возвращает аргумент переданный panic. Поскольку единственный код, который работает во время разматывания - это код, находящийся внутри отложенных функций, restore полезен только внутри отложенных функций.
Одно из применений recover - отключение отказавшей go-процедуры внутри сервера, не убивая другие исполняемые go-процедуры.


## Немного про память

Стек (stack) — это область оперативной памяти, которая создаётся для каждого потока. Работают в режиме LIFO. Стек быстрый, так как часто привязан к кэшу процессора. Размер стека ограничен, и задаётся при создании потока. При объявлении новой переменной она помещается в стек, при исчезновении переменной из зоны видимости она удаляется из стека, в этот момент память становится свободной для другой стековой переменной. 
(Стеку не нужно иметь сборщик мусора. Стек принадлежит одной горутине, переменные не нужно синхронизировать)

Куча (heap) — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. Размер кучи ограничен лишь физически. Она медленнее, потому что переменные разбросаны по памяти, а не сидят на верхушке стека. 

## ...

Сериализация — это процесс преобразования объекта в поток байтов для сохранения или передачи. Обратной операцией является десериализация (т.е. восстановление объекта/структуры из последовательности байтов). Синонимом можно считать термин "маршалинг" (marshal — упорядочивать).
Из минусов сериализации можно выделить нарушение инкапсуляции, т.е. после сериализации "приватные" свойства структур могут быть доступны для изменения.
Типичными примерами сериализации в Go являются преобразование структур в json-объекты.

В Go применяется "утиная типизация". Чтобы сообщить компилятору, что ваш тип реализует определенный интерфейс в Go, вам необходимо явно объявить это, указав имя интерфейса после имени типа в объявлении.

## Замыкание

В Go функции можно передавать как обычные значения. Внутри функций можно создавать другие функции, как анонимные значения, которые также можно передавать. 
Особенностью языка является доступность состояния внешней функции из анонимных функций, даже после ее завершения. 
Замыкание - вложенная функция, сохраняющая доступ к переменным внешней функции даже после завершения последней.
Замыкание - внутри функции используем переменную, которая объявлена за функцией. 

```go
func f1() func() int {
    i := 0

    return func() int {
        i++
        return i
    }
}
```

## Ключевые слова

1. Break
2. Case
3. Chan 
4. Const
5. Continue
6. Default
7. Defer
8. Else
9. Fallthrough
10. For
11. Func
12. Go
13. Go to
14. If
15. Import
16. Interface
17. Map
18. Package
19. Range
20. Return 
21. Select
22. Struct
23. Switch
24. Type
25. Var

## Каналы и пайпы

Пайпы и каналы в Go являются различными средствами для передачи данных, применяются в разных контекстах и работают по-разному.

В программировании на Go пайпы (pipes) представляют собой способ установления связи между различными процессами, чтобы они могли обмениваться данными. Пайпы можно использовать для передачи данных (обычно в виде потоков байтов) между различными частями программы.

В Go пайпы могут быть созданы с помощью функции io.Pipe(), которая создает взаимосвязанные части типа io.Reader и io.Writer. Это означает, что данные, записанные в io.Writer, могут быть прочитаны из io.Reader. Пайпы часто используются для связи внутри одного процесса или между горутинами.

Пайпы могут быть полезны в случаях, когда необходимо передать данные между различными частями программы, не используя прямую коммуникацию через переменные, а также для реализации конвейерных вычислений, когда данные должны последовательно обрабатываться несколькими функциями или горутинами.


Разница:
1. Синтаксис: 
   - Пайпы создаются с помощью оператора | в командной оболочке, а каналы создаются с помощью функций make(chan type) в Go.
2. Способ передачи данных: 
   - Пайпы работают с использованием стандартных потоков ввода/вывода, в то время как каналы в Go используются для передачи данных между горутинами.
3. Применение: 
   - Пайпы используются для связи процессов в командной оболочке, в то время как каналы в Go используются для синхронизации и обмена данными между горутинами.
4. Блокировка: 
   - При чтении данных из пайпа процесс может блокироваться, если данных нет, в то время как операции с каналами могут быть блокирующими или неблокирующими в зависимости от спецификации операций.




